---
# Deploy all VMStation applications to Kubernetes cluster
# Master playbook that orchestrates all application deployments
#
# Usage:
#   ansible-playbook playbooks/deploy-applications.yml -e deploy_environment=production
#   ansible-playbook playbooks/deploy-applications.yml -e deploy_environment=staging
#   ansible-playbook playbooks/deploy-applications.yml -e deploy_environment=production --tags jellyfin
#
# Prerequisites:
#   - Kubernetes cluster is running
#   - kubectl is configured on the control plane node
#   - Required storage and network configurations are in place

- name: "Deploy VMStation Applications"
  hosts: kube-master
  become: true
  gather_facts: true
  
  vars:
    # Default deployment environment
    # NOTE: do not use the variable name "environment" here; it's a reserved Ansible keyword.
    deploy_environment: production
    
    # Applications to deploy (can be overridden)
    deploy_jellyfin: true
    deploy_nextcloud: true
    
    # Paths
    kustomize_path: "{{ playbook_dir }}/../../kustomize"
    manifests_path: "{{ playbook_dir }}/../../manifests"
    
    # Deployment settings
    wait_timeout: 600
    
  tasks:
    - name: "Pre-deployment validation"
      tags: [always]
      block:
        - name: "Validate environment selection"
          ansible.builtin.assert:
            that:
              - deploy_environment in ['production', 'staging']
            fail_msg: "Invalid deploy_environment '{{ deploy_environment }}'. Must be 'production' or 'staging'."

        - name: "Verify cluster connectivity"
          ansible.builtin.command: kubectl cluster-info
          register: cluster_info
          changed_when: false
          failed_when: cluster_info.rc != 0

        - name: "Display cluster information"
          ansible.builtin.debug:
            msg: "Connected to Kubernetes cluster: {{ cluster_info.stdout_lines | first }}"

    - name: "Deploy common resources"
      tags: [common]
      block:
        - name: "Apply common namespace"
          ansible.builtin.command: "kubectl apply -f {{ manifests_path }}/common/namespace.yaml"
          register: common_ns_apply
          changed_when: "'configured' in common_ns_apply.stdout or 'created' in common_ns_apply.stdout"

        - name: "Apply resource quotas"
          ansible.builtin.command: "kubectl apply -f {{ manifests_path }}/common/resource-quotas.yaml"
          register: rq_apply
          changed_when: "'configured' in rq_apply.stdout or 'created' in rq_apply.stdout"

    - name: "Deploy Jellyfin"
      tags: [jellyfin]
      when: deploy_jellyfin | bool
      block:
        - name: "Include Jellyfin preparation"
          ansible.builtin.include_tasks:
            file: ../tasks/jellyfin-prep.yml
          vars:
            deploy_environment: "{{ deploy_environment }}"

    - name: "Deploy Nextcloud"
      tags: [nextcloud]
      when: deploy_nextcloud | bool
      block:
        - name: "Include Nextcloud preparation"
          ansible.builtin.include_tasks:
            file: ../tasks/nextcloud-prep.yml
          vars:
            deploy_environment: "{{ deploy_environment }}"

    - name: "Apply application stack"
      tags: [apply]
      ansible.builtin.include_tasks:
        file: ../tasks/apply-stack-overlay.yml
      vars:
        deploy_environment: "{{ deploy_environment }}"

    - name: "Wait for Jellyfin deployment"
      tags: [jellyfin]
      when: deploy_jellyfin | bool
      ansible.builtin.command: "kubectl -n jellyfin rollout status deploy/jellyfin --timeout={{ wait_timeout }}s"
      register: jellyfin_rollout
      changed_when: false
      failed_when: false

    - name: "Verify Jellyfin SSO (oauth2-proxy) configuration"
      tags: [jellyfin]
      when: deploy_jellyfin | bool
      ansible.builtin.include_tasks:
        file: ../tasks/jellyfin-sso-verify.yml

    - name: "Wait for Nextcloud deployment"
      tags: [nextcloud]
      when: deploy_nextcloud | bool
      ansible.builtin.command: "kubectl -n nextcloud rollout status deploy/nextcloud --timeout={{ wait_timeout }}s"
      register: nextcloud_rollout
      changed_when: false
      failed_when: false

    - name: "Post-deployment verification"
      tags: [always]
      block:
        - name: "Get application pods"
          ansible.builtin.command: "kubectl -n {{ item }} get pods -o wide"
          loop:
            - jellyfin
            - nextcloud
            - vmstation-apps
          register: all_pods
          changed_when: false
          failed_when: false

        - name: "Display deployment summary"
          ansible.builtin.debug:
            msg: |
              ========================================
              VMStation Application Deployment Summary
              ========================================
              Environment: {{ deploy_environment }}
              
              Deployed Namespaces:
              {% for ns_result in all_pods.results %}
              - {{ ns_result.item }}:
              {{ (ns_result.stdout_lines | default(['(no output)'])) | join('\n              ') }}
              {% endfor %}
              ========================================

- name: "Verify storage node configuration"
  hosts: storage_nodes
  become: true
  gather_facts: false
  tags: [storage, verify]
  
  tasks:
    - name: "Check Jellyfin directories"
      ansible.builtin.stat:
        path: "{{ item }}"
      loop:
        - /var/lib/jellyfin
        - /mnt/media
      register: dir_check

    - name: "Display storage status"
      ansible.builtin.debug:
        msg: "{{ item.item }}: {{ 'EXISTS' if item.stat.exists else 'MISSING' }}"
      loop: "{{ dir_check.results }}"

- name: "Verify compute node configuration"
  hosts: compute_nodes
  become: true
  gather_facts: false
  tags: [compute, verify]

  tasks:
    - name: "Check Nextcloud directories"
      ansible.builtin.stat:
        path: "{{ item }}"
      loop:
        - /srv/nextcloud/nextcloud
        - /srv/nextcloud/mariadb
      register: nextcloud_dir_check

    - name: "Display compute node storage status"
      ansible.builtin.debug:
        msg: "{{ item.item }}: {{ 'EXISTS' if item.stat.exists else 'MISSING' }}"
      loop: "{{ nextcloud_dir_check.results }}"
